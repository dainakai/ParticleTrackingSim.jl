## 3次元球形粒子運動シミュレーションコード開発 タスクリスト

**目的:** 要件定義書 (v1.1 Final) に基づき、3D-PTVベンチマークデータ生成用シミュレーションコードをJuliaで開発する。

**前提:** 各タスクはGitHub Issueとして起票されることを想定。タスク番号、タイトル、詳細な内容、関連する要件定義書項目、および検証方法（テスト要件）を記載する。

---

### フェーズ 1: プロジェクト基盤構築 (Setup & Core Structure)

**Task 01: Juliaプロジェクト初期化とGitリポジトリ設定**
*   **内容:**
    *   Juliaの標準的なプロジェクト構造（`Project.toml`, `src/`, `test/`, `docs/`, `examples/`, `data/` (出力用) など）を持つ新しいJuliaプロジェクトを作成する。
    *   プロジェクト名を決定する (例: `ParticleTrackingSim.jl`)。
    *   `src/` 内にメインモジュールファイル (例: `ParticleTrackingSim.jl`) を作成する。
    *   Gitリポジトリを初期化し、適切な `.gitignore` ファイル（Juliaプロジェクト、OS固有ファイル、データファイル用）を追加する。
    *   初期コミットを行い、リモートリポジトリ (GitHub) にプッシュする。
*   **関連要件:** NFR-MAINT-01, NFR-MAINT-03
*   **検証:**
    *   `julia --project -e 'using Pkg; Pkg.instantiate()'` がエラーなく実行できる。
    *   基本的なディレクトリ構造が存在する。
    *   `.gitignore` が適切に設定されている。

**Task 02: 基本的なモジュール構造定義**
*   **内容:**
    *   `src/` 内に、主要機能に対応するサブモジュールまたはファイルをプレースホルダとして作成する。
        *   `Environment.jl` (環境設定関連)
        *   `FlowFields.jl` (流れ場生成関連)
        *   `Particles.jl` (粒子データ構造、初期化関連)
        *   `Dynamics.jl` (粒子運動計算、時間積分関連)
        *   `BoundaryConditions.jl` (周期境界条件関連)
        *   `IO.jl` (入出力関連)
        *   `Utils.jl` (共通ユーティリティ、乱数生成器管理など)
        *   `Visualization.jl` (可視化関連)
    *   メインモジュール (`ParticleTrackingSim.jl`) からこれらのサブモジュールを `include` または `using` する構成にする。
*   **関連要件:** NFR-MAINT-01
*   **検証:**
    *   `using ParticleTrackingSim` がエラーなく実行できる。
    *   各サブモジュールが認識されている。

**Task 03: 設定ファイル読み込み機能の実装**
*   **内容:**
    *   シミュレーションパラメータ（FR-ENV, FR-FLOW, FR-PART, FR-DYN, FR-OUT で定義されるもの）を外部ファイル（例: `config.toml` または `config.json`）から読み込む機能を実装する。
    *   読み込むパラメータの構造を定義する（例: Juliaの `struct` を使用）。
    *   設定ファイルが存在しない場合や、必須パラメータが欠けている場合にエラーを出す処理を実装する。
    *   依存パッケージ `TOML.jl` または `JSON3.jl` を `Project.toml` に追加する。
*   **関連要件:** FR-ENV-*, FR-FLOW-*, FR-PART-*, FR-DYN-*, FR-OUT-* (パラメータ項目), NFR-MAINT-03
*   **検証:**
    *   サンプル設定ファイルを正しく読み込み、対応するJulia構造体に格納できることを確認するユニットテストを作成する。
    *   不正な設定ファイル（欠損、型間違い）に対してエラーが発生することを確認するテストを作成する。

**Task 04: 環境パラメータ管理構造の実装**
*   **内容:**
    *   `Environment.jl` 内に、計算領域 (`Lx, Ly, Lz`)、時間設定 (`Tmax, dt`)、物理定数 (`g`, `ρ_f`, `μ_f`, `ν_f`)、単位系の情報、乱数シードなどを保持するための構造体（例: `SimEnvironment`）を定義する。
    *   Task 03 で読み込んだ設定から、この構造体のインスタンスを生成する関数を実装する。
    *   乱数生成器 (`StableRNGs.jl` を使用）の初期化と管理を行う機能を `Utils.jl` または `Environment.jl` に実装する (FR-ENV-05)。
*   **関連要件:** FR-ENV-01, FR-ENV-02, FR-ENV-03, FR-ENV-04, FR-ENV-05, NFR-MAINT-03
*   **検証:**
    *   設定値から `SimEnvironment` インスタンスが正しく生成されることを確認するユニットテストを作成する。
    *   指定したシードで乱数生成器が初期化され、再現可能な乱数列が生成されることを確認するテストを作成する。

### フェーズ 2: 流れ場生成 (Flow Field Generation)

**Task 05: 流れ場モジュールのインターフェース定義**
*   **内容:**
    *   `FlowFields.jl` 内に、異なる流れ場タイプに共通のインターフェースを定義する。
        *   抽象型 `AbstractFlowField` を定義する。
        *   各流れ場タイプが実装すべき関数を定義する（例: `get_velocity(flow::AbstractFlowField, x, y, z, t)`）。
        *   流れ場生成関数（例: `generate_flow_field(config)`）のインターフェースを定義し、設定に応じて適切な流れ場オブジェクトを返すようにする。
*   **関連要件:** FR-FLOW-00
*   **検証:**
    *   インターフェース定義が適切であり、将来的な流れ場追加が容易な構造になっていることをコードレビューで確認する。

**Task 06: フーリエ（スペクトル）乱流場の実装**
*   **内容:**
    *   `FlowFields.jl` 内に `SpectralTurbulenceFlow <: AbstractFlowField` 構造体と関連メソッドを実装する。
    *   **入力:** `Nx, Ny, Nz`, `Lx, Ly, Lz`, 目標スペクトル $E(k)$ (パラメータ形式 or 関数)、乱流強度 $u'_{rms}$、乱数生成器。
    *   **処理:**
        1.  波数ベクトル $\mathbf{k}$ を定義。
        2.  目標スペクトルとランダム位相から初期フーリエ係数 $\tilde{\mathbf{u}}_{init}(\mathbf{k})$ を生成 (FR-FLOW-03-03 step 1)。実数場条件を満たすこと。
        3.  $u'_{rms}$ に基づきスペクトルを規格化 (FR-FLOW-03-02)。
        4.  フーリエ空間での非圧縮化（投影演算子 $\mathbf{P}(\mathbf{k})$ を適用）(FR-FLOW-03-03 step 2)。$\mathbf{k}=\mathbf{0}$ の扱いに注意。
        5.  逆高速フーリエ変換 (IFFT) を実行し、実空間速度場 $\mathbf{u}(\mathbf{x})$ のグリッドデータを生成 (FR-FLOW-03-03 step 3)。`FFTW.jl` を使用。
        6.  生成されたグリッドデータを保持する構造体を定義する。
    *   **依存:** `FFTW.jl`, `StableRNGs.jl`
*   **関連要件:** FR-FLOW-01, FR-FLOW-03-01, FR-FLOW-03-02, FR-FLOW-03-03, FR-FLOW-03-04, NFR-MAINT-03
*   **検証:**
    *   生成された速度場の発散が数値的にゼロに近いことを確認するテスト (`∇⋅u ≈ 0`)。
    *   生成された場のエネルギースペクトルが目標スペクトルに一致することを確認するテスト。
    *   生成された場の乱流強度 $u'_{rms}$ が指定値に一致することを確認するテスト。
    *   IFFTの結果が実数であることを確認するテスト。

**Task 07: 層流せん断流の実装**
*   **内容:**
    *   `FlowFields.jl` 内に `LaminarShearFlow <: AbstractFlowField` 構造体と関連メソッドを実装する。
    *   **入力:** せん断率 $S$、せん断形式（例: `:xy` は $u=(Sy, 0, 0)$）。
    *   **処理:** `get_velocity(flow, x, y, z, t)` が指定された形式の速度ベクトルを返すように実装する。
*   **関連要件:** FR-FLOW-01, FR-FLOW-04-01, FR-FLOW-04-02, FR-FLOW-04-04 (frozen time)
*   **検証:**
    *   指定した点における速度ベクトルが理論値と一致することを確認するユニットテストを作成する。
    *   発散がゼロであることを（解析的に自明だが）確認するテスト。

**Task 08: ABCフローの実装**
*   **内容:**
    *   `FlowFields.jl` 内に `ABCFlow <: AbstractFlowField` 構造体と関連メソッドを実装する。
    *   **入力:** パラメータ $A, B, C$、波数 $k_x, k_y, k_z$。
    *   **処理:** `get_velocity(flow, x, y, z, t)` がABCフローの定義式 (FR-FLOW-05-01) に基づく速度ベクトルを返すように実装する。
*   **関連要件:** FR-FLOW-01, FR-FLOW-05-01, FR-FLOW-05-02, FR-FLOW-05-04 (frozen time)
*   **検証:**
    *   指定した点における速度ベクトルが理論値と一致することを確認するユニットテストを作成する。
    *   発散がゼロであることを確認するテスト（数値的または解析的）。

**Task 09: Taylor-Green (TG) 渦の実装**
*   **内容:**
    *   `FlowFields.jl` 内に `TaylorGreenVortex <: AbstractFlowField` 構造体と関連メソッドを実装する。
    *   **入力:** 振幅 $U_0$、波数 $k_x, k_y, k_z$、(オプション) 動粘性係数 $\nu_f$ (減衰モード用)。
    *   **処理:** `get_velocity(flow, x, y, z, t)` がTG渦の定義式 (FR-FLOW-06-01 で確定した式) に基づく速度ベクトルを返すように実装する。時間依存性（`:frozen` または `:decaying`）を考慮する。
*   **関連要件:** FR-FLOW-01, FR-FLOW-06-01, FR-FLOW-06-02, FR-FLOW-06-04
*   **検証:**
    *   指定した点、時刻における速度ベクトルが理論値と一致することを確認するユニットテストを作成する。
    *   発散がゼロであることを確認するテスト。
    *   `:decaying` モードの場合、時間経過に伴うエネルギー減衰率が理論値と一致することを確認するテスト。

**Task 10: 流れ場の時間変動モデルの実装**
*   **内容:**
    *   `FlowFields.jl` 内で、時間変動モード `:frozen`, `:advect`, `:blend`, `:decaying` (FR-FLOW-02) をサポートする機構を実装する。
    *   **`:frozen`:** `get_velocity` が時間 `t` に依存しないようにする（デフォルト）。
    *   **`:advect` (スペクトル乱流用):** フーリエ係数に位相シフト $\exp(i\omega_k t)$ を適用する機能を実装する。$\omega_k$ モデルとパラメータ $c_0$ を設定可能にする。
    *   **`:blend` (スペクトル乱流用):** 2つの独立な定常場を生成し、指定された混合関数 $\alpha(t)$ とパラメータ $f$ に基づいて時間的に混合する機能を実装する。
    *   **`:decaying` (TG渦用):** TG渦の `get_velocity` 内で減衰係数 $\exp(- C \nu_f k^2 t)$ を適用する。
    *   流れ場オブジェクトが自身の時間変動モードと関連パラメータを保持するようにする。
*   **関連要件:** FR-FLOW-02, FR-FLOW-03-05, FR-FLOW-04-04, FR-FLOW-05-04, FR-FLOW-06-04
*   **検証:**
    *   各時間変動モードについて、異なる時刻で `get_velocity` を呼び出し、期待される速度値（定常、位相シフト、混合、減衰）が得られることを確認するテストを作成する。

**Task 11: 任意点での流体速度補間機能の実装**
*   **内容:**
    *   `FlowFields.jl` または `Utils.jl` に、グリッドデータとして与えられた流れ場（特にスペクトル乱流）から、任意の粒子位置 $\mathbf{x}_p$ における流体速度 $\mathbf{u}(\mathbf{x}_p, t)$ を補間計算する機能を実装する。
    *   補間方法（線形補間、3次スプライン補間など）を選択可能にする (FR-DYN-01)。
    *   依存パッケージ `Interpolations.jl` を `Project.toml` に追加する。
*   **関連要件:** FR-DYN-01, NFR-MAINT-03, NFR-RIGOR-01
*   **検証:**
    *   既知の解析的な流れ場をグリッドデータ化し、グリッド点およびグリッド中間点での補間値が元の解析解と一致（または高精度で近似）することを確認するテストを作成する。
    *   異なる補間方法の精度を比較するテスト。

### フェーズ 3: 粒子設定と運動計算 (Particle Setup & Dynamics)

**Task 12: 粒子データ構造の定義**
*   **内容:**
    *   `Particles.jl` 内に、個々の粒子の状態を保持する構造体（例: `Particle`）を定義する。
    *   少なくとも以下の情報を含むこと:
        *   軌跡ID: `id::UUID` (FR-PART-03)
        *   位置: `position::Vector{Float64}` (or `SVector{3, Float64}`)
        *   速度: `velocity::Vector{Float64}` (or `SVector{3, Float64}`)
        *   直径: `diameter::Float64` (FR-PART-04)
        *   密度: `density::Float64` (FR-PART-05)
        *   応答時間: `tau_p::Float64` (FR-DYN-01, FR-DYN-02)
        *   (必要に応じて) 境界横断フラグなど
    *   依存パッケージ `UUIDs.jl` を `Project.toml` に追加する。
*   **関連要件:** FR-PART-03, FR-PART-04, FR-PART-05, FR-DYN-01, FR-DYN-02, NFR-MAINT-03
*   **検証:**
    *   `Particle` 構造体のインスタンスが正しく生成・アクセスできることを確認する。
    *   UUIDが正しく生成・格納されることを確認する。

**Task 13: 粒子初期化機能の実装**
*   **内容:**
    *   `Particles.jl` 内に、指定された総粒子数 `Np` の粒子群を初期化する関数（例: `initialize_particles(Np, env, flow, config)`）を実装する。
    *   **位置:** 計算領域内に一様ランダムに配置 (FR-PART-01)。`StableRNGs.jl` を使用。
    *   **直径:** 設定された分布（単一、一様、正規、対数正規、カスタム）に従って各粒子に直径を割り当て (FR-PART-04)。`Distributions.jl` を使用する場合は依存に追加。負の直径が生成されないように注意。
    *   **密度:** 全粒子に単一の密度 `ρ_p` を設定 (FR-PART-05)。
    *   **応答時間:** 慣性指定オプション (FR-DYN-02) に基づき、各粒子の $\tau_p$ を計算。
        *   物理量ベース: $\tau_p = \rho_p d_p^2 / (18 \mu_f)$
        *   Stokes数ベース: $\tau_p = St \times \tau_f$ (基準時間スケール $\tau_f$ の定義と値が必要)
    *   **初期速度:** 各粒子の初期位置における流体速度 $\mathbf{u}(\mathbf{x}_p(0), 0)$ を設定 (FR-PART-02)。Task 11 の補間関数を使用。
    *   **ID:** 各粒子に一意なUUIDを割り当て (FR-PART-03)。
*   **関連要件:** FR-PART-01, FR-PART-02, FR-PART-03, FR-PART-04, FR-PART-05, FR-DYN-02, FR-ENV-05
*   **検証:**
    *   指定された数の粒子が生成されることを確認するテスト。
    *   粒子位置が指定領域内にあり、分布が一様であることを統計的に確認するテスト。
    *   粒子直径が指定された分布に従うことを統計的に確認するテスト。
    *   初期速度が対応する位置の流体速度と一致することを確認するテスト。
    *   各粒子がユニークなUUIDを持つことを確認するテスト。
    *   $\tau_p$ が正しく計算されていることを確認するテスト。

**Task 14: 粒子運動方程式の数値積分機能の実装**
*   **内容:**
    *   `Dynamics.jl` 内に、単一時間ステップにおける粒子運動方程式 (FR-DYN-01) を解く関数（例: `step_particle!(particle, flow, env, dt)`）を実装する。
    *   $\frac{d\mathbf{x}_p}{dt} = \mathbf{v}_p$
    *   $\frac{d\mathbf{v}_p}{dt} = \frac{1}{\tau_p} [\mathbf{u}(\mathbf{x}_p(t), t) - \mathbf{v}_p(t)] + (1 - \frac{\rho_f}{\rho_p}) \mathbf{g}$
    *   数値積分法（例: 2次Runge-Kutta (Heun法), Velocity-Verlet）を実装 (FR-DYN-03)。
    *   粒子位置での流体速度取得には Task 11 の補間関数を使用。
    *   重力項 $\mathbf{g}=(0, -g, 0)$ を考慮 (FR-ENV-03)。
*   **関連要件:** FR-DYN-01, FR-DYN-03, FR-ENV-03, NFR-RIGOR-01
*   **検証:**
    *   **静止流体中の沈降:** $\mathbf{u}=\mathbf{0}$ の場合、終端速度が理論値 $(1-\rho_f/\rho_p)\mathbf{g}\tau_p$ に漸近することを確認するテスト。
    *   **一様流:** $\mathbf{u}=\mathbf{const}$ の場合、粒子速度が $\mathbf{u}$ に漸近することを確認するテスト。
    *   **時間ステップ依存性:** 時間ステップ `dt` を変えて実行し、結果の収束性を確認するテスト（例: `dt` を半分にすると誤差が1/4になるか、など）。
    *   既知の解析解が存在する単純なケース（例: Stokes流中の振動流）と比較するテスト。

**Task 15: 周期境界条件処理の実装**
*   **内容:**
    *   `BoundaryConditions.jl` 内に、粒子の位置を更新した後に周期境界条件を適用する関数（例: `apply_periodic_boundary!(particle, env)`）を実装する。
    *   粒子が計算領域 (`[0, Lx]`, `[0, Ly]`, `[0, Lz]`) の外に出た場合、対向する面から再進入させる (FR-DYN-04)。
    *   例: `if x > Lx; x -= Lx; elseif x < 0; x += Lx; end` (y, z も同様)。
    *   境界を横断したかどうかを示すフラグを返すか、粒子状態に記録する。
*   **関連要件:** FR-DYN-04
*   **検証:**
    *   境界のすぐ外側に粒子を配置し、関数適用後に正しい対向位置に移動することを確認するユニットテスト。
    *   複数回境界を横断するケースをテストする。
    *   各次元（x, y, z）および各境界（下限、上限）で正しく機能することを確認するテスト。

**Task 16: 境界横断時の軌跡ID更新機能の実装**
*   **内容:**
    *   `Dynamics.jl` またはメインループ内で、Task 15 で境界横断が検出された場合に、粒子の軌跡IDを新しいUUIDに更新する処理を実装する (FR-DYN-05)。
    *   古いIDでの軌跡記録を終了し、新しいIDで記録を開始するシグナルを出す（または状態を変更する）。
    *   依存パッケージ `UUIDs.jl` を使用。
*   **関連要件:** FR-DYN-05, FR-PART-03
*   **検証:**
    *   境界を横断する粒子をシミュレートし、横断後にIDが新しいUUIDに変更されることを確認するテスト。
    *   連続して境界を横断した場合でも、その都度新しいIDが付与されることを確認するテスト。

### フェーズ 4: シミュレーション実行と出力 (Simulation Loop & Output)

**Task 17: メインシミュレーションループの実装**
*   **内容:**
    *   メインモジュールまたは `Dynamics.jl` に、時間 `t=0` から `Tmax` まで、時間刻み `dt` でシミュレーションを進めるループを実装する (FR-4 参照)。
    *   ループの各ステップで、全粒子に対して以下を実行:
        1.  粒子位置での流体速度を取得 (Task 11)。
        2.  粒子運動方程式を1ステップ積分 (Task 14)。
        3.  周期境界条件を適用 (Task 15)。
        4.  境界横断を検出し、IDを更新 (Task 16)。
        5.  出力判定とデータ記録 (Task 19, Task 20 で実装するデータ構造へ)。
    *   マルチスレッディング (`Threads.@threads`) を用いた粒子計算ループの並列化を検討・実装する (NFR-PERF-01)。
*   **関連要件:** FR-4, FR-ENV-02, NFR-PERF-01
*   **検証:**
    *   シミュレーションが指定された `Tmax` までエラーなく実行されることを確認する。
    *   簡単な設定（少数粒子、短時間）で実行し、粒子位置が時間とともに変化することを確認する。
    *   並列化した場合としない場合で結果が（数値誤差の範囲で）一致することを確認するテスト。
    *   プロファイリングを行い、ボトルネックを特定し、パフォーマンスが妥当な範囲にあることを確認する (NFR-PERF-01)。

**Task 18: メタデータ出力機能の実装**
*   **内容:**
    *   `IO.jl` 内に、シミュレーション開始時または終了時に、全ての入力パラメータ、設定値、RNGシード、コードバージョン/GitハッシュなどをJSON形式で `metadata.json` ファイルに出力する関数を実装する (FR-OUT-01)。
    *   依存パッケージ `JSON3.jl` を使用。
    *   Gitハッシュ取得には `Git.jl` または外部コマンド呼び出しを使用。
*   **関連要件:** FR-OUT-01, FR-OUT-04, NFR-MAINT-03
*   **検証:**
    *   生成された `metadata.json` が有効なJSON形式であることを確認する。
    *   ファイルに必要なキー（パラメータ名）が全て含まれ、値が設定ファイルや実行時情報と一致することを確認するユニットテスト。

**Task 19: 軌跡データ出力機能の実装**
*   **内容:**
    *   `IO.jl` 内に、シミュレーション中に各粒子の時系列データ（時刻 `t`, 座標 `x, y, z`）を軌跡ID (UUID文字列) ごとに収集し、シミュレーション終了後に指定された形式の `trajectories.json` ファイルに出力する機能を実装する (FR-OUT-02)。
    *   データ構造: `Dict{String, Dict{String, Vector{Float64}}}` (UUID文字列 -> {"t", "x", "y", "z"} -> データ配列)。
    *   境界横断でIDが変わるため、各IDに対応するデータは空間的に連続な軌跡となる。
    *   大量データになる可能性を考慮し、メモリ効率の良いデータ蓄積方法を検討する（必要に応じて段階的にファイル書き出しも検討）。
    *   依存パッケージ `JSON3.jl`, `UUIDs.jl` を使用。
*   **関連要件:** FR-OUT-02, FR-OUT-04, FR-OUT-05, FR-DYN-05
*   **検証:**
    *   生成された `trajectories.json` が指定されたJSON構造に従っていることを確認するテスト。
    *   ファイル内のデータがシミュレーション結果（特定の粒子の位置履歴）と一致することを確認するテスト。
    *   境界を横断した粒子の軌跡が、横断前のIDと横断後のIDで別々のエントリとして記録されていることを確認するテスト。
    *   各軌跡ID内の座標データが空間的に連続（ジャンプがない）ことを確認するテスト。

**Task 20: スナップショットデータ出力機能の実装**
*   **内容:**
    *   `IO.jl` 内に、指定された時間間隔 (`n_out * dt`) ごとに、その時刻に存在する全粒子の情報（現在の軌跡ID (UUID文字列), 座標 `x, y, z`, 粒子径 `dp`）を収集し、シミュレーション終了後に指定された形式の `snapshots.json` ファイルに出力する機能を実装する (FR-OUT-03)。
    *   データ構造: `Dict{String, Vector{Dict{String, Any}}}` (時刻文字列 -> [粒子情報辞書配列])。粒子情報辞書は `{"id": "uuid_str", "x": ..., "y": ..., "z": ..., "dp": ...}`。
    *   依存パッケージ `JSON3.jl`, `UUIDs.jl` を使用。
*   **関連要件:** FR-OUT-03, FR-OUT-04, FR-OUT-05
*   **検証:**
    *   生成された `snapshots.json` が指定されたJSON構造に従っていることを確認するテスト。
    *   ファイル内の特定の時刻のスナップショットデータが、その時刻のシミュレーション状態と一致することを確認するテスト。
    *   出力間隔が正しく守られていることを確認するテスト。

### フェーズ 5: 可視化とドキュメント、テスト (Visualization, Docs & Testing)

**Task 21: 可視化ユーティリティのセットアップ**
*   **内容:**
    *   `Visualization.jl` モジュールを作成する。
    *   `Makie.jl` と `Plots.jl` を `Project.toml` の `[extras]` セクションと `test/Project.toml` に追加する（メインコードの依存には含めない）。
    *   基本的なプロット関数を呼び出すためのラッパー関数を `Visualization.jl` に用意する。
*   **関連要件:** FR-VIS-04, NFR-MAINT-03
*   **検証:**
    *   `using ParticleTrackingSim.Visualization` が（適切な環境で）エラーなく実行できる。
    *   両方のバックエンド（Makie, Plots）で簡単なプロットが描画できることを確認するサンプルコードまたはテスト。

**Task 22: フレーム（スナップショット）表示機能の実装**
*   **内容:**
    *   `Visualization.jl` 内に、`snapshots.json` または対応するデータ構造から指定されたフレーム（時刻）の粒子分布を3D散布図で表示する関数 `plot_frame(data, frame_key; backend=:makie)` を実装する (FR-VIS-01)。
    *   オプションで粒径 `dp` に応じてマーカーのサイズや色を変更できるようにする。
    *   `Makie.jl` と `Plots.jl` の両方に対応する。
*   **関連要件:** FR-VIS-01, FR-VIS-04
*   **検証:**
    *   サンプルデータを用いて、指定したフレームの粒子が正しく3D空間にプロットされることを確認する（目視確認または画像比較テスト）。
    *   両方のバックエンドで同等の表示が得られることを確認する。

**Task 23: 軌跡表示機能の実装**
*   **内容:**
    *   `Visualization.jl` 内に、`trajectories.json` または対応するデータ構造から指定された軌跡ID（単数または複数、UUID文字列）の粒子軌跡を3Dラインプロットで表示する関数 `plot_trajectory(data, trajectory_ids; backend=:makie)` を実装する (FR-VIS-02)。
    *   複数の軌跡を同時に表示できるようにする。
    *   `Makie.jl` と `Plots.jl` の両方に対応する。
*   **関連要件:** FR-VIS-02, FR-VIS-04
*   **検証:**
    *   サンプルデータを用いて、指定したIDの軌跡が正しく3D空間に線でプロットされることを確認する（目視確認または画像比較テスト）。
    *   両方のバックエンドで同等の表示が得られることを確認する。

**Task 24: (オプション) 流れ場ベクトル表示機能の実装**
*   **内容:**
    *   `Visualization.jl` 内に、指定された平面（例: z=const）における流れ場の速度ベクトルを2Dベクトルプロット（Quiver plot）で表示する関数 `plot_flow_slice(flow, plane_axis, plane_value, t; resolution=32, backend=:makie)` を実装する (FR-VIS-03)。
    *   `Makie.jl` と `Plots.jl` の両方に対応する。
*   **関連要件:** FR-VIS-03, FR-VIS-04
*   **検証:**
    *   既知の流れ場（例: 層流せん断）について、ベクトルプロットが期待されるパターンを示すことを確認する。

**Task 25: (オプション) アニメーション生成機能の実装**
*   **内容:**
    *   `Visualization.jl` 内に、`snapshots.json` データから粒子運動のアニメーションを生成する関数 `animate_particles(snapshot_data; filename="particle_animation.mp4", backend=:makie)` を実装する。
    *   `trajectories.json` データから軌跡が時間とともに伸びていくアニメーションを生成する関数 `animate_trajectories(trajectory_data; ...)` を実装することも検討する。
    *   `Makie.jl` または `Plots.jl` のアニメーション機能を利用する。
*   **関連要件:** FR-VIS-04
*   **検証:**
    *   生成されたアニメーションファイルが再生可能であり、粒子や軌跡が時間とともに正しく変化することを確認する。

**Task 26: ユニットテストとインテグレーションテストの実装**
*   **内容:**
    *   `test/runtests.jl` を設定し、`Test.jl` を用いたテストスイートを構築する。
    *   各モジュール（流れ場、粒子、動力学、IOなど）に対して、これまでのタスクで記述された検証項目をユニットテストとして実装する。
    *   **特に重要なテスト:**
        *   流れ場の非圧縮性確認 (Task 06)。
        *   粒子運動の解析解との比較 (Task 14)。
        *   周期境界条件とID更新の連携確認 (Task 15, 16)。
        *   JSON入出力のフォーマットと内容の検証 (Task 18, 19, 20)。
    *   いくつかのパラメータ設定を用いた小規模なインテグレーションテスト（シミュレーション全体を実行し、最終状態や出力ファイルを確認）を実装する。
*   **関連要件:** NFR-RIGOR-02, (各タスクの検証項目)
*   **検証:**
    *   `pkg> test ParticleTrackingSim` が成功する。
    *   テストカバレッジ計測ツール（例: `Coverage.jl`）を導入し、カバレッジレポートを生成する。目標カバレッジ (例: 80%) を目指す (NFR-RIGOR-02)。

**Task 27: ドキュメント作成 (README, Docstrings)**
*   **内容:**
    *   プロジェクトの目的、インストール方法、設定ファイルの書き方、実行方法、出力ファイル形式（JSON構造の詳細含む、FR-OUT-05）、可視化ツールの使い方、簡単な例題などを記載した `README.md` を作成する。
    *   公開する主要な関数や構造体に対して、標準的なフォーマットで Docstring を記述する (NFR-MAINT-02)。
    *   使用する数値アルゴリズム（補間、時間積分）の選択理由や特性に関する簡単な説明をドキュメントまたはコードコメントに追加する (NFR-RIGOR-01)。
    *   時間刻み `dt` の選択に関するガイドラインを提供する (FR-DYN-03)。
*   **関連要件:** FR-OUT-05, FR-DYN-03, NFR-MAINT-02, NFR-RIGOR-01
*   **検証:**
    *   README が分かりやすく、ユーザーが必要な情報を見つけられるかレビューする。
    *   Docstring が適切に記述されており、`? FunctionName` でヘルプが表示されることを確認する。
    *   ドキュメント生成ツール（例: `Documenter.jl`）の導入を検討する。

**Task 28: コード品質と依存関係管理**
*   **内容:**
    *   コード全体が Julia の標準的なコーディングスタイルガイドに従っていることを確認する。リンター（例: `JET.jl`）やフォーマッター（例: `JuliaFormatter.jl`）の利用を検討する。
    *   `Project.toml` に記載された依存関係が最新かつ必要最小限であることを確認する。
    *   Julia バージョン 1.10 以降での動作を確認する (NFR-CODE-01)。
*   **関連要件:** NFR-MAINT-02, NFR-MAINT-03, NFR-CODE-01
*   **検証:**
    *   コードレビューを実施する。
    *   リンターやフォーマッターを実行し、指摘事項を修正する。
    *   指定されたJuliaバージョンでテストがすべて通ることを確認する。

---

**GitHub Issueへの起票について:**
上記の各タスクを個別のGitHub Issueとして起票してください。Issueのタイトルは「Task XX: [タスクの要約]」のようにし、本文に「内容」「関連要件」「検証」のセクションを含めると管理しやすくなります。依存関係のあるタスクはIssue間でリンクすると良いでしょう。